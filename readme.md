# Transaction Manager
In my project, I have implemented all 5 functions of transaction manager such as BeginTx, ReadTx, WriteTx, AbortTx and CommitTx.
The first operation any transaction encounters is BeginTx. Transaction Manager object will be initialised with appropriate values in this function. This is done after locking the transaction manager. This brings the transaction to active state. Each operation in the BeginTx function explained with easy understandable comments in the code.
Second function is ReadTx, which is called when the transaction has to access the object for reading the data. This in turn call the set_lock function which grants two type of locks. Exclusive lock Read/Write transaction. Shared lock for Read only transaction. If the requesting transaction already holds a lock on the object, it directly moves on to perform_readWrite function. If the requesting transaction needs a lock on a object which is currently being used by another transaction, it is put in the waiting queue. To grant the object a lock, it is put on to Hash table and then it can move on to perform_readWrite. Comment section in the code explains each and every scenario of set_lock function.
Third function WriteTx is also similar to readTx, this function is called when the transaction has to access an object to write on to it. WriteTx also calls set_lock and exclusive lock is granted, and in perform_readWrite,  write is simulated.
After Read and Write Transaction has to commit if it executed smoothly or has to be Aborted if there occurs any error. AbortTx aborts any transaction. AbortTx call the do_commit_abort function. Here all the holding locks are set to free. All the waiting transactions are informed that locks are set free by doing the ‘v’ operation on the sem_no. Similarly, CommitTx calls do_commit_abort and sets all the locks free of the transactions being commited.
